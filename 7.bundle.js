(window.webpackJsonp=window.webpackJsonp||[]).push([[7,12],{249:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_redux__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(27);\n\n\n\nfunction capitalizeFirstLetter(string) {\n  return string.charAt(0).toUpperCase() + string.slice(1);\n}\n\nvar TaskList = function TaskList(props) {\n  var indent = [];\n  if (props.tasks) props.tasks.forEach(function (prop) {\n    if (prop !== \'empty\') indent.push(react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("option", {\n      key: prop,\n      value: prop\n    }, capitalizeFirstLetter(prop)));\n  });\n  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("select", {\n    className: "focus__btnPanel-tasks",\n    onChange: function onChange(e) {\n      props.onTaskChange(e.target.value);\n    }\n  }, indent);\n};\n\nvar mapsStateToProps = function mapsStateToProps(state) {\n  return {\n    tasks: !!state.tasks ? Object.keys(state.tasks) : false\n  };\n};\n\nvar ConnectedTaskList = Object(react_redux__WEBPACK_IMPORTED_MODULE_1__[/* connect */ "b"])(mapsStateToProps)(TaskList);\n/* harmony default export */ __webpack_exports__["default"] = (ConnectedTaskList);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjQ5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL0NvbXBvbmVudHMvQXRvbWljQ29tcG9uZW50cy9UYXNrTGlzdC5qcz8wMDZkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQge2Nvbm5lY3R9IGZyb20gJ3JlYWN0LXJlZHV4JztcblxuZnVuY3Rpb24gY2FwaXRhbGl6ZUZpcnN0TGV0dGVyKHN0cmluZykge1xuICAgIHJldHVybiBzdHJpbmcuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHJpbmcuc2xpY2UoMSk7XG59XG5cbmNvbnN0IFRhc2tMaXN0ID0gKHByb3BzKSA9PiB7XG4gICAgbGV0IGluZGVudCA9IFtdO1xuICAgIFxuICAgIGlmKHByb3BzLnRhc2tzKVxuICAgICAgICBwcm9wcy50YXNrcy5mb3JFYWNoKHByb3AgPT4ge1xuICAgICAgICAgICAgaWYocHJvcCAhPT0gJ2VtcHR5JylcbiAgICAgICAgICAgICAgICBpbmRlbnQucHVzaCg8b3B0aW9uIGtleT17cHJvcH0gdmFsdWU9e3Byb3B9PntjYXBpdGFsaXplRmlyc3RMZXR0ZXIocHJvcCl9PC9vcHRpb24+KVxuICAgICAgICB9KTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxzZWxlY3QgY2xhc3NOYW1lPSdmb2N1c19fYnRuUGFuZWwtdGFza3MnIG9uQ2hhbmdlPXsoZSk9PntcbiAgICAgICAgICAgIHByb3BzLm9uVGFza0NoYW5nZShlLnRhcmdldC52YWx1ZSlcbiAgICAgICAgfX0+XG4gICAgICAgICAgICB7aW5kZW50fVxuICAgICAgICA8L3NlbGVjdD5cbiAgICApXG59O1xuXG5jb25zdCBtYXBzU3RhdGVUb1Byb3BzID0gKHN0YXRlKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdGFza3M6ICEhc3RhdGUudGFza3M/T2JqZWN0LmtleXMoc3RhdGUudGFza3MpOmZhbHNlXG4gICAgfVxufVxuY29uc3QgQ29ubmVjdGVkVGFza0xpc3QgPSBjb25uZWN0KG1hcHNTdGF0ZVRvUHJvcHMpKFRhc2tMaXN0KTtcblxuZXhwb3J0IGRlZmF1bHQgQ29ubmVjdGVkVGFza0xpc3Q7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFGQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFBQTtBQUVBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///249\n')},457:function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "assets/refresh-button.svg";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDU3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2Fzc2V0cy9yZWZyZXNoLWJ1dHRvbi5zdmc/OTU2NiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCJhc3NldHMvcmVmcmVzaC1idXR0b24uc3ZnXCI7Il0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///457\n')},482:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: ./node_modules/react/index.js\nvar react = __webpack_require__(0);\nvar react_default = /*#__PURE__*/__webpack_require__.n(react);\n\n// EXTERNAL MODULE: ./node_modules/react-redux/es/index.js + 17 modules\nvar es = __webpack_require__(27);\n\n// EXTERNAL MODULE: ./node_modules/moment/moment.js\nvar moment = __webpack_require__(20);\nvar moment_default = /*#__PURE__*/__webpack_require__.n(moment);\n\n// EXTERNAL MODULE: ./src/Components/AtomicComponents/TaskList.js\nvar TaskList = __webpack_require__(249);\n\n// EXTERNAL MODULE: ./node_modules/react-chartjs-2/es/index.js\nvar react_chartjs_2_es = __webpack_require__(364);\n\n// CONCATENATED MODULE: ./src/Components/AtomicComponents/Chart.js\n\n\n\nvar Chart_Chart = function Chart(props) {\n  if (props.type === \'bar\') return react_default.a.createElement(react_chartjs_2_es["a" /* Bar */], {\n    data: props.data,\n    options: {\n      title: {\n        display: true,\n        fontSize: 18,\n        text: props.title\n      },\n      legend: false\n    }\n  });else if (props.type === \'line\') return react_default.a.createElement(react_chartjs_2_es["c" /* Line */], {\n    data: props.data,\n    options: {\n      title: {\n        display: true,\n        fontSize: 18,\n        text: props.title\n      },\n      legend: false,\n      maintainAspectRatio: false,\n      responsive: true\n    }\n  });else if (props.type === \'doughnut\') return react_default.a.createElement("div", {\n    className: "doughnutChart"\n  }, react_default.a.createElement(react_chartjs_2_es["b" /* Doughnut */], {\n    data: props.data,\n    options: {\n      title: {\n        display: true,\n        fontSize: 18,\n        text: props.title\n      },\n      legend: false,\n      maintainAspectRatio: false,\n      responsive: true\n    }\n  }), react_default.a.createElement("div", {\n    className: "stats__doughnut-legend"\n  }, react_default.a.createElement("span", {\n    className: "stats__doughnut-legend-completed"\n  }, "Completed"), react_default.a.createElement("span", {\n    className: "stats__doughnut-legend-incomplete"\n  }, "Incomplete")));\n};\n\n/* harmony default export */ var AtomicComponents_Chart = (Chart_Chart);\n// EXTERNAL MODULE: ./src/firebase/firebase.js\nvar firebase = __webpack_require__(29);\n\n// EXTERNAL MODULE: ./src/assets/refresh-button.svg\nvar refresh_button = __webpack_require__(457);\nvar refresh_button_default = /*#__PURE__*/__webpack_require__.n(refresh_button);\n\n// CONCATENATED MODULE: ./src/Components/Stats.js\nfunction _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === \'function\') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n\n\n\n\n\n\nvar Stats_Stats =\n/*#__PURE__*/\nfunction (_Component) {\n  _inherits(Stats, _Component);\n\n  function Stats(props) {\n    var _this;\n\n    _classCallCheck(this, Stats);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Stats).call(this, props));\n    /*the state contains value for the dropdown lists as those change,\n     what is rendered in the component should also change*/\n\n    _defineProperty(_assertThisInitialized(_this), "filterFetchedDataByDays", function (days) {\n      var beginDate;\n      if (days === \'month\') beginDate = moment_default()().subtract(1, \'month\').calendar().split(\'/\');else if (days === \'6months\') beginDate = moment_default()().subtract(6, \'month\').calendar().split(\'/\');else if (typeof days === \'number\') beginDate = moment_default()().subtract(days, \'days\').calendar().split(\'/\'); //logic for extrating datelist\n\n      /*this logic is flawed and the whole logic should be implemented in a backend \n      since all lot of extracting needs to be done which will\n       spoil the user experience */\n\n      beginDate = beginDate[2] + beginDate[0] + beginDate[1];\n      var dateList;\n      var allDatesInDB = Object.keys(_this.fetchedData).sort().reverse();\n\n      if (allDatesInDB.indexOf(beginDate) === -1) {\n        var diff = 10000,\n            indx;\n        allDatesInDB.every(function (date) {\n          if (parseInt(date) - parseInt(beginDate) < 0) return false;\n\n          if (parseInt(date) - parseInt(beginDate) < diff) {\n            diff = parseInt(date) - parseInt(beginDate);\n            indx = allDatesInDB.indexOf(date);\n          }\n\n          return true;\n        });\n        dateList = allDatesInDB.slice(allDatesInDB.indexOf(_this.props.date), allDatesInDB.indexOf(indx));\n      } else dateList = allDatesInDB.slice(allDatesInDB.indexOf(_this.props.date), allDatesInDB.indexOf(beginDate));\n\n      dateList.forEach(function (date) {\n        _this.filteredData[date] = _this.fetchedData[date];\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_this), "filterDataByTasks", function () {\n      if (_this.fetchedData[_this.state.dashboard.task]) _this.filteredData = _this.fetchedData[_this.state.dashboard.task];\n    });\n\n    _defineProperty(_assertThisInitialized(_this), "extractDatesLabel", function () {\n      _this.dateLabelList = [];\n      Object.keys(_this.filteredData).forEach(function (date) {\n        _this.dateLabelList.push(date.split(\'\').slice(6, 8).join(\'\') + \':\' + date.split(\'\').slice(4, 6).join(\'\') + \':\' + date.split(\'\').slice(0, 4).join(\'\'));\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_this), "fetchData", function () {\n      _this.fetchedData = undefined;\n      _this.filteredData = {}; //Logic when data to be fetched is of today\n\n      if (_this.state.dashboard.rangeOfData === \'today\') {\n        firebase["a" /* default */].ref("users/".concat(_this.props.uid, "/data/").concat(_this.props.date)).once("value", function (snapshot) {\n          if (snapshot.val()) {\n            _this.fetchedData = snapshot.val();\n          }\n        }).then(function () {\n          //******LOGIC TO FILTER DATA*******\n          //if data is to be filtered for a specific task for today\n          if (_this.state.dashboard.displayBy === \'tasks\') {\n            _this.filterDataByTasks(); //setting state to map data\n\n\n            _this.setState(function (state) {\n              return _objectSpread({}, state, {\n                type: \'bar\',\n                data: {\n                  labels: Object.keys(_this.filteredData),\n                  datasets: [{\n                    label: \'Sessions\',\n                    data: Object.values(_this.filteredData).concat(0),\n                    backgroundColor: [\'rgba(31, 221, 114, 0.6)\', \'rgba(255, 75, 30, 0.6)\']\n                  }]\n                }\n              });\n            }); //if data is to be filtered for all tasks for today\n\n          } else if (_this.state.dashboard.displayBy === \'all\') {\n            var labels = Object.keys(_this.fetchedData);\n            var completed = [],\n                incomplete = [];\n            labels.forEach(function (label) {\n              completed.push(_this.fetchedData[label].completed);\n              incomplete.push(_this.fetchedData[label].incomplete);\n            });\n\n            _this.setState(function (state) {\n              return _objectSpread({}, state, {\n                type: \'doughnut\',\n                data: {\n                  labels: labels,\n                  datasets: [{\n                    label: \'completed\',\n                    data: completed.concat(0),\n                    backgroundColor: \'rgba(31, 221, 114, 0.6)\'\n                  }, {\n                    label: \'incomplete\',\n                    data: incomplete.concat(0),\n                    backgroundColor: \'rgba(255, 75, 30, 0.6)\'\n                  }]\n                }\n              });\n            });\n          }\n        }); //below is logic when data to be fetched is for some certain no of past days \n      } else {\n        var fetchDays;\n        if (_this.state.dashboard.rangeOfData === \'week\') fetchDays = 7;else if (_this.state.dashboard.rangeOfData === \'month\') fetchDays = \'month\';else if (_this.state.dashboard.rangeOfData === \'6months\') fetchDays = \'6months\'; //so get all the data at once and then filter that locally rather than fetching data for each day \n\n        firebase["a" /* default */].ref("users/".concat(_this.props.uid, "/data")).once("value", function (snapshot) {\n          if (snapshot.val()) {\n            if (snapshot.val()) _this.fetchedData = snapshot.val();\n          }\n        }).then(function () {\n          /*filtering data for a specified number of days */\n          _this.filterFetchedDataByDays(fetchDays);\n\n          if (_this.state.dashboard.displayBy === \'tasks\') {\n            //getting the labels and filtering them according to availability of the task on that date\n            //================***********================\n            var labels = Object.keys(_this.filteredData);\n            labels = labels.filter(function (key) {\n              if (Object.keys(_this.filteredData[key]).includes(!_this.state.dashboard.task ? _this.props.intialTask : _this.state.dashboard.task)) return true;\n            }); //=================***********================\n\n            var completed = [],\n                incomplete = []; //fetching completed and incomplete session for the available date for the sellected task\n\n            labels.forEach(function (date) {\n              completed.push(_this.filteredData[date][!_this.state.dashboard.task ? _this.props.intialTask : _this.state.dashboard.task].completed);\n              incomplete.push(_this.filteredData[date][!_this.state.dashboard.task ? _this.props.intialTask : _this.state.dashboard.task].incomplete);\n            });\n\n            _this.extractDatesLabel(); //setting state to map data\n\n\n            _this.setState(function (state) {\n              return _objectSpread({}, state, {\n                type: \'line\',\n                data: {\n                  labels: _this.dateLabelList,\n                  datasets: [{\n                    label: \'Completed\',\n                    data: completed.concat(0),\n                    borderColor: \'rgba(31, 221, 114, 0.6)\',\n                    pointHoverBackgroundColor: \'rgba(31, 221, 114, 0.6)\',\n                    fill: false\n                  }, {\n                    label: \'Incomplete\',\n                    data: incomplete.concat(0),\n                    borderColor: \'rgba(255, 75, 30, 0.6)\',\n                    pointHoverBackgroundColor: \'rgba(255, 75, 30, 0.6)\',\n                    fill: false\n                  }]\n                }\n              });\n            });\n          } else if (_this.state.dashboard.displayBy === \'all\') {\n            //got the date list\n            var dateList = Object.keys(_this.filteredData);\n            var _labels = []; //fetching the tasks for labels\n\n            dateList.forEach(function (date) {\n              Object.keys(_this.filteredData[date]).forEach(function (label) {\n                if (!_labels.includes(label)) _labels.push(label);\n              });\n            });\n            var _completed = [],\n                tempPushcompleted = [],\n                _incomplete = [],\n                tempPushincomplete = []; //summing up total complete and incomplete sessions for each task\n\n            _labels.forEach(function (label) {\n              tempPushcompleted = [], tempPushincomplete = [];\n              dateList.forEach(function (date) {\n                if (_this.filteredData[date][label]) {\n                  tempPushcompleted.push(_this.filteredData[date][label].completed);\n                  tempPushincomplete.push(_this.filteredData[date][label].incomplete);\n                }\n              });\n\n              if (tempPushcompleted.length) {\n                var sum = tempPushcompleted.reduce(function (accumulator, a) {\n                  return accumulator + a;\n                });\n\n                _completed.push(sum);\n              }\n\n              if (tempPushincomplete.length) {\n                var _sum = tempPushincomplete.reduce(function (accumulator, a) {\n                  return accumulator + a;\n                });\n\n                _incomplete.push(_sum);\n              }\n            });\n\n            _this.setState(function (state) {\n              return _objectSpread({}, state, {\n                type: \'doughnut\',\n                data: {\n                  labels: _labels,\n                  datasets: [{\n                    label: \'completed\',\n                    data: _completed.concat(0),\n                    backgroundColor: \'rgba(31, 221, 114, 0.6)\'\n                  }, {\n                    label: \'incomplete\',\n                    data: _incomplete.concat(0),\n                    backgroundColor: \'rgba(255, 75, 30, 0.6)\'\n                  }]\n                }\n              });\n            });\n          }\n        });\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), "handleOnChange", function (identifier, value) {\n      var Dash = _this.state.dashboard;\n      Dash[identifier] = value;\n\n      _this.setState(function (state) {\n        return _objectSpread({}, state, {\n          dashboard: Dash\n        });\n      });\n\n      _this.fetchData();\n    });\n\n    _this.state = {\n      dashboard: {\n        displayBy: \'tasks\',\n        rangeOfData: \'today\',\n        task: \'\'\n      },\n      data: {},\n      type: \'\',\n      rotateClass: \'stats__chartboard\'\n    };\n    _this.fetchedData = undefined;\n    _this.filteredData = {};\n    _this.dateLabelList = [];\n    return _this;\n  }\n\n  _createClass(Stats, [{\n    key: "componentDidMount",\n    value: function componentDidMount() {\n      var _this2 = this;\n\n      this.setState(function (state) {\n        return _objectSpread({}, state, {\n          dashboard: {\n            displayBy: \'tasks\',\n            rangeOfData: \'today\',\n            task: _this2.props.intialTask\n          }\n        });\n      });\n    }\n    /*As you will notice below on every change to the dropdown list "handleOnChange()" is called*/\n\n  }, {\n    key: "render",\n    value: function render() {\n      var _this3 = this;\n\n      return react_default.a.createElement("div", {\n        className: "stats"\n      }, react_default.a.createElement("div", {\n        className: "stats__dashboard"\n      }, react_default.a.createElement("select", {\n        name: "displayBy",\n        className: "focus__btnPanel-tasks",\n        onChange: function onChange(e) {\n          _this3.handleOnChange(\'displayBy\', e.target.value);\n        }\n      }, react_default.a.createElement("option", {\n        value: "tasks"\n      }, "By Tasks"), react_default.a.createElement("option", {\n        value: "all"\n      }, "All")), react_default.a.createElement("select", {\n        name: "rangeOfData",\n        className: "focus__btnPanel-tasks",\n        onChange: function onChange(e) {\n          _this3.handleOnChange(\'rangeOfData\', e.target.value);\n        }\n      }, react_default.a.createElement("option", {\n        value: "today"\n      }, "Today"), react_default.a.createElement("option", {\n        value: "week"\n      }, "Last week"), react_default.a.createElement("option", {\n        value: "month"\n      }, "Last month"), react_default.a.createElement("option", {\n        value: "6months"\n      }, "Last 6 months")), this.state.dashboard.displayBy === \'tasks\' && react_default.a.createElement(TaskList["default"], {\n        onTaskChange: function onTaskChange(task) {\n          _this3.handleOnChange(\'task\', task);\n        }\n      })), react_default.a.createElement("div", {\n        className: "stats__rotate",\n        onClick: function onClick() {\n          _this3.setState(function (state) {\n            return _objectSpread({}, state, {\n              rotateClass: state.rotateClass === \'stats__chartboard active\' ? \'stats__chartboard\' : \'stats__chartboard active\'\n            });\n          });\n        }\n      }, react_default.a.createElement("img", {\n        className: "stats__rotate-img",\n        src: refresh_button_default.a\n      })), react_default.a.createElement("div", {\n        className: this.state.rotateClass\n      }, this.state.type && react_default.a.createElement(AtomicComponents_Chart, {\n        data: this.state.data,\n        title: this.state.dashboard.task.toUpperCase(),\n        type: this.state.type\n      })));\n    }\n  }]);\n\n  return Stats;\n}(react["Component"]);\n\n;\n\nvar mapStateToProps = function mapStateToProps(store) {\n  return {\n    uid: store.auth.cred.uid,\n    date: Object.keys(store.data)[0],\n    intialTask: Object.keys(store.tasks)[0]\n  };\n};\n\n/* harmony default export */ var Components_Stats = __webpack_exports__["default"] = (Object(es["b" /* connect */])(mapStateToProps)(Stats_Stats));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDgyLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL0NvbXBvbmVudHMvQXRvbWljQ29tcG9uZW50cy9DaGFydC5qcz9lZjE0Iiwid2VicGFjazovLy8uL3NyYy9Db21wb25lbnRzL1N0YXRzLmpzPzRjMTkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7QmFyLExpbmUsRG91Z2hudXR9IGZyb20gJ3JlYWN0LWNoYXJ0anMtMic7XG5cbmNvbnN0IENoYXJ0ID0gKHByb3BzKSA9PiB7XG4gICAgaWYocHJvcHMudHlwZSA9PT0gJ2JhcicpXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8QmFyIFxuICAgICAgICAgICAgICAgIGRhdGE9e3Byb3BzLmRhdGF9XG4gICAgICAgICAgICAgICAgb3B0aW9ucz17e1xuICAgICAgICAgICAgICAgICAgICB0aXRsZTp7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6dHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZm9udFNpemU6MTgsXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IHByb3BzLnRpdGxlXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGxlZ2VuZDpmYWxzZVxuICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAvPlxuICAgICAgICApXG4gICAgZWxzZSBpZihwcm9wcy50eXBlID09PSAnbGluZScpXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8TGluZSBcbiAgICAgICAgICAgICAgICBkYXRhPXtwcm9wcy5kYXRhfVxuICAgICAgICAgICAgICAgIG9wdGlvbnM9e3tcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6e1xuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OnRydWUsXG4gICAgICAgICAgICAgICAgICAgIGZvbnRTaXplOjE4LFxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBwcm9wcy50aXRsZVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBsZWdlbmQ6ZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIG1haW50YWluQXNwZWN0UmF0aW8gOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2l2ZTogdHJ1ZVxuICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAvPlxuICAgICAgICApXG4gICAgZWxzZSBpZihwcm9wcy50eXBlID09PSAnZG91Z2hudXQnKVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJkb3VnaG51dENoYXJ0XCI+XG4gICAgICAgICAgICAgICAgPERvdWdobnV0IFxuICAgICAgICAgICAgICAgIGRhdGE9e3Byb3BzLmRhdGF9XG4gICAgICAgICAgICAgICAgb3B0aW9ucz17e1xuICAgICAgICAgICAgICAgICAgICB0aXRsZTp7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6dHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZm9udFNpemU6MTgsXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IHByb3BzLnRpdGxlXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGxlZ2VuZDpmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgbWFpbnRhaW5Bc3BlY3RSYXRpbyA6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICByZXNwb25zaXZlOiB0cnVlXG4gICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT0nc3RhdHNfX2RvdWdobnV0LWxlZ2VuZCc+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPSdzdGF0c19fZG91Z2hudXQtbGVnZW5kLWNvbXBsZXRlZCc+Q29tcGxldGVkPC9zcGFuPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT0nc3RhdHNfX2RvdWdobnV0LWxlZ2VuZC1pbmNvbXBsZXRlJz5JbmNvbXBsZXRlPC9zcGFuPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKSBcblxufTtcblxuZXhwb3J0IGRlZmF1bHQgQ2hhcnQ7XG4iLCJpbXBvcnQgUmVhY3Qse0NvbXBvbmVudH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHtjb25uZWN0fSBmcm9tICdyZWFjdC1yZWR1eCc7XG5cbmltcG9ydCBtb21lbnQgZnJvbSAnbW9tZW50JztcblxuaW1wb3J0IFRhc2tMaXN0IGZyb20gJy4vQXRvbWljQ29tcG9uZW50cy9UYXNrTGlzdCc7XG5pbXBvcnQgQ2hhcnQgZnJvbSAnLi9BdG9taWNDb21wb25lbnRzL0NoYXJ0JztcblxuaW1wb3J0IGRhdGFiYXNlIGZyb20gJy4uL2ZpcmViYXNlL2ZpcmViYXNlJztcblxuaW1wb3J0IHJvdGF0ZVN2ZyBmcm9tICcuLi9hc3NldHMvcmVmcmVzaC1idXR0b24uc3ZnJztcblxuY2xhc3MgU3RhdHMgZXh0ZW5kcyBDb21wb25lbnR7XG4gICAgY29uc3RydWN0b3IocHJvcHMpe1xuICAgICAgICBzdXBlcihwcm9wcyk7XG5cbiAgICAgICAgLyp0aGUgc3RhdGUgY29udGFpbnMgdmFsdWUgZm9yIHRoZSBkcm9wZG93biBsaXN0cyBhcyB0aG9zZSBjaGFuZ2UsXG4gICAgICAgICB3aGF0IGlzIHJlbmRlcmVkIGluIHRoZSBjb21wb25lbnQgc2hvdWxkIGFsc28gY2hhbmdlKi9cbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIGRhc2hib2FyZDoge1xuICAgICAgICAgICAgICAgIGRpc3BsYXlCeTogJ3Rhc2tzJyxcbiAgICAgICAgICAgICAgICByYW5nZU9mRGF0YTogJ3RvZGF5JyxcbiAgICAgICAgICAgICAgICB0YXNrOiAnJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRhdGE6IHt9LFxuICAgICAgICAgICAgdHlwZTogJycsXG4gICAgICAgICAgICByb3RhdGVDbGFzcyA6ICdzdGF0c19fY2hhcnRib2FyZCdcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5mZXRjaGVkRGF0YSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5maWx0ZXJlZERhdGEgPSB7fTtcblxuICAgICAgICB0aGlzLmRhdGVMYWJlbExpc3QgPSBbXTtcbiAgICB9O1xuXG4gICAgZmlsdGVyRmV0Y2hlZERhdGFCeURheXMgPSAoZGF5cykgPT4ge1xuICAgICAgICBsZXQgYmVnaW5EYXRlO1xuICAgICAgICBpZihkYXlzID09PSAnbW9udGgnKVxuICAgICAgICAgICAgYmVnaW5EYXRlID0gbW9tZW50KCkuc3VidHJhY3QoMSwgJ21vbnRoJykuY2FsZW5kYXIoKS5zcGxpdCgnLycpO1xuICAgICAgICBlbHNlIGlmKGRheXMgPT09ICc2bW9udGhzJylcbiAgICAgICAgICAgIGJlZ2luRGF0ZSA9IG1vbWVudCgpLnN1YnRyYWN0KDYsICdtb250aCcpLmNhbGVuZGFyKCkuc3BsaXQoJy8nKTtcbiAgICAgICAgZWxzZSBpZih0eXBlb2YoZGF5cykgPT09ICdudW1iZXInKVxuICAgICAgICAgICAgYmVnaW5EYXRlID0gbW9tZW50KCkuc3VidHJhY3QoZGF5cywgJ2RheXMnKS5jYWxlbmRhcigpLnNwbGl0KCcvJyk7XG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgLy9sb2dpYyBmb3IgZXh0cmF0aW5nIGRhdGVsaXN0XG4gICAgICAgIC8qdGhpcyBsb2dpYyBpcyBmbGF3ZWQgYW5kIHRoZSB3aG9sZSBsb2dpYyBzaG91bGQgYmUgaW1wbGVtZW50ZWQgaW4gYSBiYWNrZW5kIFxuICAgICAgICBzaW5jZSBhbGwgbG90IG9mIGV4dHJhY3RpbmcgbmVlZHMgdG8gYmUgZG9uZSB3aGljaCB3aWxsXG4gICAgICAgICBzcG9pbCB0aGUgdXNlciBleHBlcmllbmNlICovXG4gICAgICAgIGJlZ2luRGF0ZSA9IGJlZ2luRGF0ZVsyXStiZWdpbkRhdGVbMF0rYmVnaW5EYXRlWzFdXG4gICAgICAgIGxldCBkYXRlTGlzdDtcbiAgICAgICAgY29uc3QgYWxsRGF0ZXNJbkRCID0gT2JqZWN0LmtleXModGhpcy5mZXRjaGVkRGF0YSkuc29ydCgpLnJldmVyc2UoKTtcbiAgICAgICAgXG4gICAgICAgIGlmKGFsbERhdGVzSW5EQi5pbmRleE9mKGJlZ2luRGF0ZSkgPT09IC0xKXtcbiAgICAgICAgICAgIGxldCBkaWZmPTEwMDAwLGluZHg7XG5cbiAgICAgICAgICAgIGFsbERhdGVzSW5EQi5ldmVyeSgoZGF0ZSkgPT4ge1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmKHBhcnNlSW50KGRhdGUpIC0gcGFyc2VJbnQoYmVnaW5EYXRlKSA8IDApXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgICAgIGlmKHBhcnNlSW50KGRhdGUpIC0gcGFyc2VJbnQoYmVnaW5EYXRlKSA8IGRpZmYpe1xuICAgICAgICAgICAgICAgICAgICBkaWZmID0gcGFyc2VJbnQoZGF0ZSkgLSBwYXJzZUludChiZWdpbkRhdGUpXG4gICAgICAgICAgICAgICAgICAgIGluZHggPSBhbGxEYXRlc0luREIuaW5kZXhPZihkYXRlKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIGRhdGVMaXN0ID0gYWxsRGF0ZXNJbkRCLnNsaWNlKGFsbERhdGVzSW5EQi5pbmRleE9mKHRoaXMucHJvcHMuZGF0ZSksYWxsRGF0ZXNJbkRCLmluZGV4T2YoaW5keCkpO1xuICAgICAgICB9ZWxzZVxuICAgICAgICAgICAgZGF0ZUxpc3QgPSBhbGxEYXRlc0luREIuc2xpY2UoYWxsRGF0ZXNJbkRCLmluZGV4T2YodGhpcy5wcm9wcy5kYXRlKSxhbGxEYXRlc0luREIuaW5kZXhPZihiZWdpbkRhdGUpKTsgICAgXG5cbiAgICAgICAgZGF0ZUxpc3QuZm9yRWFjaCgoZGF0ZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5maWx0ZXJlZERhdGFbZGF0ZV0gPSB0aGlzLmZldGNoZWREYXRhW2RhdGVdO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmaWx0ZXJEYXRhQnlUYXNrcyA9ICgpID0+IHtcbiAgICAgICAgaWYodGhpcy5mZXRjaGVkRGF0YVt0aGlzLnN0YXRlLmRhc2hib2FyZC50YXNrXSlcbiAgICAgICAgICAgIHRoaXMuZmlsdGVyZWREYXRhID0gdGhpcy5mZXRjaGVkRGF0YVt0aGlzLnN0YXRlLmRhc2hib2FyZC50YXNrXVxuICAgIH1cblxuICAgIGV4dHJhY3REYXRlc0xhYmVsID0gKCkgPT4ge1xuICAgICAgICB0aGlzLmRhdGVMYWJlbExpc3QgPSBbXTtcbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5maWx0ZXJlZERhdGEpLmZvckVhY2goKGRhdGUpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZGF0ZUxhYmVsTGlzdC5wdXNoKFxuICAgICAgICAgICAgICAgIGRhdGUuc3BsaXQoJycpLnNsaWNlKDYsOCkuam9pbignJykrJzonK1xuICAgICAgICAgICAgICAgIGRhdGUuc3BsaXQoJycpLnNsaWNlKDQsNikuam9pbignJykrJzonK1xuICAgICAgICAgICAgICAgIGRhdGUuc3BsaXQoJycpLnNsaWNlKDAsNCkuam9pbignJykpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy9mZXRjaGluZyBkYXRhIGZyb20gZmlyZWJhc2VcbiAgICBmZXRjaERhdGEgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMuZmV0Y2hlZERhdGEgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuZmlsdGVyZWREYXRhID0ge307XG4gICAgICAgIC8vTG9naWMgd2hlbiBkYXRhIHRvIGJlIGZldGNoZWQgaXMgb2YgdG9kYXlcbiAgICAgICAgaWYodGhpcy5zdGF0ZS5kYXNoYm9hcmQucmFuZ2VPZkRhdGEgPT09ICd0b2RheScpe1xuICAgICAgICAgICAgZGF0YWJhc2UucmVmKGB1c2Vycy8ke3RoaXMucHJvcHMudWlkfS9kYXRhLyR7dGhpcy5wcm9wcy5kYXRlfWApLm9uY2UoXCJ2YWx1ZVwiLCAoc25hcHNob3QpID0+IHtcbiAgICAgICAgICAgICAgICBpZihzbmFwc2hvdC52YWwoKSl7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmV0Y2hlZERhdGEgPSBzbmFwc2hvdC52YWwoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyoqKioqKkxPR0lDIFRPIEZJTFRFUiBEQVRBKioqKioqKlxuXG4gICAgICAgICAgICAgICAgLy9pZiBkYXRhIGlzIHRvIGJlIGZpbHRlcmVkIGZvciBhIHNwZWNpZmljIHRhc2sgZm9yIHRvZGF5XG4gICAgICAgICAgICAgICAgaWYodGhpcy5zdGF0ZS5kYXNoYm9hcmQuZGlzcGxheUJ5ID09PSAndGFza3MnKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maWx0ZXJEYXRhQnlUYXNrcygpXG4gICAgICAgICAgICAgICAgICAgIC8vc2V0dGluZyBzdGF0ZSB0byBtYXAgZGF0YVxuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoKHN0YXRlKSA9PiAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYmFyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbHM6IE9iamVjdC5rZXlzKHRoaXMuZmlsdGVyZWREYXRhKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhc2V0czogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOidTZXNzaW9ucycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6T2JqZWN0LnZhbHVlcyh0aGlzLmZpbHRlcmVkRGF0YSkuY29uY2F0KDApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6W1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3JnYmEoMzEsIDIyMSwgMTE0LCAwLjYpJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdyZ2JhKDI1NSwgNzUsIDMwLCAwLjYpJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy9pZiBkYXRhIGlzIHRvIGJlIGZpbHRlcmVkIGZvciBhbGwgdGFza3MgZm9yIHRvZGF5XG4gICAgICAgICAgICAgICAgfWVsc2UgaWYodGhpcy5zdGF0ZS5kYXNoYm9hcmQuZGlzcGxheUJ5ID09PSAnYWxsJyl7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxhYmVscyA9IE9iamVjdC5rZXlzKHRoaXMuZmV0Y2hlZERhdGEpO1xuXG4gICAgICAgICAgICAgICAgICAgIGxldCBjb21wbGV0ZWQgPSBbXSwgaW5jb21wbGV0ZSA9IFtdO1xuXG4gICAgICAgICAgICAgICAgICAgIGxhYmVscy5mb3JFYWNoKChsYWJlbCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxldGVkLnB1c2goKHRoaXMuZmV0Y2hlZERhdGFbbGFiZWxdKS5jb21wbGV0ZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5jb21wbGV0ZS5wdXNoKCh0aGlzLmZldGNoZWREYXRhW2xhYmVsXSkuaW5jb21wbGV0ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoKHN0YXRlKSA9PiAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZG91Z2hudXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsczogbGFiZWxzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFzZXRzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6J2NvbXBsZXRlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6Y29tcGxldGVkLmNvbmNhdCgwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOidyZ2JhKDMxLCAyMjEsIDExNCwgMC42KSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6J2luY29tcGxldGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTppbmNvbXBsZXRlLmNvbmNhdCgwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjoncmdiYSgyNTUsIDc1LCAzMCwgMC42KSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB9XG4gXG4gICAgICAgICAgICB9KTtcblxuXG4gICAgICAgICAgICAvL2JlbG93IGlzIGxvZ2ljIHdoZW4gZGF0YSB0byBiZSBmZXRjaGVkIGlzIGZvciBzb21lIGNlcnRhaW4gbm8gb2YgcGFzdCBkYXlzIFxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIGxldCBmZXRjaERheXM7XG4gICAgICAgICAgICBpZih0aGlzLnN0YXRlLmRhc2hib2FyZC5yYW5nZU9mRGF0YSA9PT0gJ3dlZWsnKVxuICAgICAgICAgICAgICAgIGZldGNoRGF5cyA9IDc7XG4gICAgICAgICAgICBlbHNlIGlmKHRoaXMuc3RhdGUuZGFzaGJvYXJkLnJhbmdlT2ZEYXRhID09PSAnbW9udGgnKVxuICAgICAgICAgICAgICAgIGZldGNoRGF5cyA9ICdtb250aCdcbiAgICAgICAgICAgIGVsc2UgaWYodGhpcy5zdGF0ZS5kYXNoYm9hcmQucmFuZ2VPZkRhdGEgPT09ICc2bW9udGhzJylcbiAgICAgICAgICAgICAgICBmZXRjaERheXMgPSAnNm1vbnRocydcblxuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy9zbyBnZXQgYWxsIHRoZSBkYXRhIGF0IG9uY2UgYW5kIHRoZW4gZmlsdGVyIHRoYXQgbG9jYWxseSByYXRoZXIgdGhhbiBmZXRjaGluZyBkYXRhIGZvciBlYWNoIGRheSBcbiAgICAgICAgICAgIGRhdGFiYXNlLnJlZihgdXNlcnMvJHt0aGlzLnByb3BzLnVpZH0vZGF0YWApLm9uY2UoXCJ2YWx1ZVwiLCAoc25hcHNob3QpID0+IHtcbiAgICAgICAgICAgICAgICBpZihzbmFwc2hvdC52YWwoKSl7XG4gICAgICAgICAgICAgICAgICAgIGlmKHNuYXBzaG90LnZhbCgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5mZXRjaGVkRGF0YSA9IHNuYXBzaG90LnZhbCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8qZmlsdGVyaW5nIGRhdGEgZm9yIGEgc3BlY2lmaWVkIG51bWJlciBvZiBkYXlzICovXG4gICAgICAgICAgICAgICAgdGhpcy5maWx0ZXJGZXRjaGVkRGF0YUJ5RGF5cyhmZXRjaERheXMpO1xuXG4gICAgICAgICAgICAgICAgaWYodGhpcy5zdGF0ZS5kYXNoYm9hcmQuZGlzcGxheUJ5ID09PSAndGFza3MnKXtcbiAgICAgICAgICAgICAgICAgICAgLy9nZXR0aW5nIHRoZSBsYWJlbHMgYW5kIGZpbHRlcmluZyB0aGVtIGFjY29yZGluZyB0byBhdmFpbGFiaWxpdHkgb2YgdGhlIHRhc2sgb24gdGhhdCBkYXRlXG4gICAgICAgICAgICAgICAgICAgIC8vPT09PT09PT09PT09PT09PSoqKioqKioqKioqPT09PT09PT09PT09PT09PVxuICAgICAgICAgICAgICAgICAgICBsZXQgbGFiZWxzID0gT2JqZWN0LmtleXModGhpcy5maWx0ZXJlZERhdGEpO1xuXG4gICAgICAgICAgICAgICAgICAgIGxhYmVscyA9IGxhYmVscy5maWx0ZXIoKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYoT2JqZWN0LmtleXModGhpcy5maWx0ZXJlZERhdGFba2V5XSkuaW5jbHVkZXMoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIXRoaXMuc3RhdGUuZGFzaGJvYXJkLnRhc2s/IHRoaXMucHJvcHMuaW50aWFsVGFzayA6IHRoaXMuc3RhdGUuZGFzaGJvYXJkLnRhc2spKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAvLz09PT09PT09PT09PT09PT09KioqKioqKioqKio9PT09PT09PT09PT09PT09XG5cblxuICAgICAgICAgICAgICAgICAgICBsZXQgY29tcGxldGVkID0gW10sIGluY29tcGxldGUgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgLy9mZXRjaGluZyBjb21wbGV0ZWQgYW5kIGluY29tcGxldGUgc2Vzc2lvbiBmb3IgdGhlIGF2YWlsYWJsZSBkYXRlIGZvciB0aGUgc2VsbGVjdGVkIHRhc2tcbiAgICAgICAgICAgICAgICAgICAgbGFiZWxzLmZvckVhY2goKGRhdGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlZC5wdXNoKCh0aGlzLmZpbHRlcmVkRGF0YVtkYXRlXVshdGhpcy5zdGF0ZS5kYXNoYm9hcmQudGFzaz8gdGhpcy5wcm9wcy5pbnRpYWxUYXNrIDp0aGlzLnN0YXRlLmRhc2hib2FyZC50YXNrXSkuY29tcGxldGVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY29tcGxldGUucHVzaCgodGhpcy5maWx0ZXJlZERhdGFbZGF0ZV1bIXRoaXMuc3RhdGUuZGFzaGJvYXJkLnRhc2s/IHRoaXMucHJvcHMuaW50aWFsVGFzayA6dGhpcy5zdGF0ZS5kYXNoYm9hcmQudGFza10pLmluY29tcGxldGUpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgXG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5leHRyYWN0RGF0ZXNMYWJlbCgpXG5cbiAgICAgICAgICAgICAgICAgICAgLy9zZXR0aW5nIHN0YXRlIHRvIG1hcCBkYXRhXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoKHN0YXRlKSA9PiAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnbGluZScsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWxzOiB0aGlzLmRhdGVMYWJlbExpc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YXNldHM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDonQ29tcGxldGVkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogY29tcGxldGVkLmNvbmNhdCgwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6ICdyZ2JhKDMxLCAyMjEsIDExNCwgMC42KScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50SG92ZXJCYWNrZ3JvdW5kQ29sb3I6J3JnYmEoMzEsIDIyMSwgMTE0LCAwLjYpJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsbDogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6J0luY29tcGxldGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogaW5jb21wbGV0ZS5jb25jYXQoMCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJDb2xvcjogJ3JnYmEoMjU1LCA3NSwgMzAsIDAuNiknLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRIb3ZlckJhY2tncm91bmRDb2xvcjogJ3JnYmEoMjU1LCA3NSwgMzAsIDAuNiknLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsbDogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH1lbHNlIGlmKHRoaXMuc3RhdGUuZGFzaGJvYXJkLmRpc3BsYXlCeSA9PT0gJ2FsbCcpe1xuICAgICAgICAgICAgICAgICAgICAvL2dvdCB0aGUgZGF0ZSBsaXN0XG4gICAgICAgICAgICAgICAgICAgIGxldCBkYXRlTGlzdCA9IE9iamVjdC5rZXlzKHRoaXMuZmlsdGVyZWREYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxhYmVscyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vZmV0Y2hpbmcgdGhlIHRhc2tzIGZvciBsYWJlbHNcbiAgICAgICAgICAgICAgICAgICAgZGF0ZUxpc3QuZm9yRWFjaCgoZGF0ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXModGhpcy5maWx0ZXJlZERhdGFbZGF0ZV0pLmZvckVhY2goKGxhYmVsKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoIWxhYmVscy5pbmNsdWRlcyhsYWJlbCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVscy5wdXNoKGxhYmVsKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvbXBsZXRlZCA9IFtdLHRlbXBQdXNoY29tcGxldGVkID0gW10sIGluY29tcGxldGU9W10sdGVtcFB1c2hpbmNvbXBsZXRlID0gW107XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAvL3N1bW1pbmcgdXAgdG90YWwgY29tcGxldGUgYW5kIGluY29tcGxldGUgc2Vzc2lvbnMgZm9yIGVhY2ggdGFza1xuICAgICAgICAgICAgICAgICAgICBsYWJlbHMuZm9yRWFjaCgobGFiZWwpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBQdXNoY29tcGxldGVkID0gW10sIHRlbXBQdXNoaW5jb21wbGV0ZSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0ZUxpc3QuZm9yRWFjaCgoZGF0ZSkgPT4geyBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZih0aGlzLmZpbHRlcmVkRGF0YVtkYXRlXVtsYWJlbF0pe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wUHVzaGNvbXBsZXRlZC5wdXNoKHRoaXMuZmlsdGVyZWREYXRhW2RhdGVdW2xhYmVsXS5jb21wbGV0ZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wUHVzaGluY29tcGxldGUucHVzaCh0aGlzLmZpbHRlcmVkRGF0YVtkYXRlXVtsYWJlbF0uaW5jb21wbGV0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZih0ZW1wUHVzaGNvbXBsZXRlZC5sZW5ndGgpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzdW0gPSB0ZW1wUHVzaGNvbXBsZXRlZC5yZWR1Y2UoKGFjY3VtdWxhdG9yLCBhKSA9PiBhY2N1bXVsYXRvciArIGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlZC5wdXNoKHN1bSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRlbXBQdXNoaW5jb21wbGV0ZS5sZW5ndGgpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzdW0gPSB0ZW1wUHVzaGluY29tcGxldGUucmVkdWNlKChhY2N1bXVsYXRvciwgYSkgPT4gYWNjdW11bGF0b3IgKyBhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmNvbXBsZXRlLnB1c2goc3VtKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoKHN0YXRlKSA9PiAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZG91Z2hudXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsczogbGFiZWxzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFzZXRzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6J2NvbXBsZXRlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6Y29tcGxldGVkLmNvbmNhdCgwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOidyZ2JhKDMxLCAyMjEsIDExNCwgMC42KSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6J2luY29tcGxldGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTppbmNvbXBsZXRlLmNvbmNhdCgwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjoncmdiYSgyNTUsIDc1LCAzMCwgMC42KSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgICBcbiAgICB9O1xuXG5cbiAgICAvKlxuICAgIHdoZW4gc29tZSBvcHRpb25zIGFyZSBjaGFuZ2VkIGJ5IHRoZSB1c2VyIHRoaXMgZnVuY3Rpb24gd2lsbCBiZSB0cmlnZ2VyIHdoaWNoIHdpbGxcbiAgICAgdXBkYXRlIHRoZSBzdGF0ZSBvZiB0aGUgY29tcG9uZW50LCBpdCBmaXJzdCBtYWtlcyBhIGNvcHkgb2YgdGhlIGN1cnJlbnQgc3RhdGUgdGhlbiB1cGRhdGVzIGNvcHkgd2l0aCBcbiAgICAgcGFzc2VkIHZhbHVlLiBGdXJ0aGVyIHNldHMtc3RhdGUgd2l0aCB0aGlzIG5ldyBcIndhbm5hIGJlXCIgc3RhdGUuXG4gICAgIEFsdGhvdWdoIHRoZSBhY3R1YWwgY2hhbmdlIGkuZS4gdGhlIG1hcCB3aWxsIG5vdCBiZSByZW5kZXJlZCBhcyBkYXRhIGZvciB0aGlzIGN1cnJlbnQgc3RhdGUgaXMgbm90IGZldGNoZWRcbiAgICAgd2hpY2ggaXMgdHJpZ2dlcmVkIHdpdGggdGhlIFwiZmV0Y2hEYXRhKClcIlxuICAgICovXG4gICAgaGFuZGxlT25DaGFuZ2UgPSAoaWRlbnRpZmllcix2YWx1ZSkgPT4ge1xuICAgICAgICBjb25zdCBEYXNoID0gdGhpcy5zdGF0ZS5kYXNoYm9hcmQ7XG4gICAgICAgIERhc2hbaWRlbnRpZmllcl0gPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSgoc3RhdGUpID0+ICh7Li4uc3RhdGUsIGRhc2hib2FyZDpEYXNofSkpO1xuXG4gICAgICAgIHRoaXMuZmV0Y2hEYXRhKCk7XG4gICAgfTtcblxuICAgIGNvbXBvbmVudERpZE1vdW50KCl7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoKHN0YXRlKSA9PiAoe1xuICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICBkYXNoYm9hcmQ6IHtcbiAgICAgICAgICAgICAgICBkaXNwbGF5Qnk6ICd0YXNrcycsXG4gICAgICAgICAgICAgICAgcmFuZ2VPZkRhdGE6ICd0b2RheScsXG4gICAgICAgICAgICAgICAgdGFzazogdGhpcy5wcm9wcy5pbnRpYWxUYXNrXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICB9XG5cbiAgICAvKkFzIHlvdSB3aWxsIG5vdGljZSBiZWxvdyBvbiBldmVyeSBjaGFuZ2UgdG8gdGhlIGRyb3Bkb3duIGxpc3QgXCJoYW5kbGVPbkNoYW5nZSgpXCIgaXMgY2FsbGVkKi9cbiAgICByZW5kZXIoKXtcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9J3N0YXRzJz5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT0nc3RhdHNfX2Rhc2hib2FyZCcgPlxuICAgICAgICAgICAgICAgICAgICA8c2VsZWN0XG4gICAgICAgICAgICAgICAgICAgIG5hbWU9J2Rpc3BsYXlCeSdcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPSdmb2N1c19fYnRuUGFuZWwtdGFza3MnXG4gICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXsoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVPbkNoYW5nZSgnZGlzcGxheUJ5JyxlLnRhcmdldC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9J3Rhc2tzJz5CeSBUYXNrczwvb3B0aW9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT0nYWxsJz5BbGw8L29wdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgPC9zZWxlY3Q+XG4gICAgICAgIFxuICAgICAgICAgICAgICAgICAgICA8c2VsZWN0XG4gICAgICAgICAgICAgICAgICAgIG5hbWU9J3JhbmdlT2ZEYXRhJ1xuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9J2ZvY3VzX19idG5QYW5lbC10YXNrcydcbiAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9eyhlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZU9uQ2hhbmdlKCdyYW5nZU9mRGF0YScsZS50YXJnZXQudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPSd0b2RheSc+VG9kYXk8L29wdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9J3dlZWsnPkxhc3Qgd2Vlazwvb3B0aW9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT0nbW9udGgnPkxhc3QgbW9udGg8L29wdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9JzZtb250aHMnPkxhc3QgNiBtb250aHM8L29wdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgPC9zZWxlY3Q+XG4gICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmRhc2hib2FyZC5kaXNwbGF5Qnk9PT0ndGFza3MnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICA8VGFza0xpc3RcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uVGFza0NoYW5nZT0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICh0YXNrKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlT25DaGFuZ2UoJ3Rhc2snLHRhc2spO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0vPlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgICAgICA8ZGl2IFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT0nc3RhdHNfX3JvdGF0ZSdcbiAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoKHN0YXRlKSA9PiAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uc3RhdGUsIFxuICAgICAgICAgICAgICAgICAgICAgICAgcm90YXRlQ2xhc3M6c3RhdGUucm90YXRlQ2xhc3MgPT09ICdzdGF0c19fY2hhcnRib2FyZCBhY3RpdmUnPyAnc3RhdHNfX2NoYXJ0Ym9hcmQnOidzdGF0c19fY2hhcnRib2FyZCBhY3RpdmUnXG4gICAgICAgICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICA8aW1nIGNsYXNzTmFtZT0nc3RhdHNfX3JvdGF0ZS1pbWcnIHNyYz17cm90YXRlU3ZnfS8+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3RoaXMuc3RhdGUucm90YXRlQ2xhc3N9PlxuICAgICAgICAgICAgICAgICAgICB7dGhpcy5zdGF0ZS50eXBlICYmIDxDaGFydCBkYXRhPXt0aGlzLnN0YXRlLmRhdGF9IHRpdGxlPXsodGhpcy5zdGF0ZS5kYXNoYm9hcmQudGFzaykudG9VcHBlckNhc2UoKX0gdHlwZT17dGhpcy5zdGF0ZS50eXBlfS8+fVxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICk7XG4gICAgfTtcbn07XG5cbmNvbnN0IG1hcFN0YXRlVG9Qcm9wcyA9IChzdG9yZSkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICAgIHVpZDogc3RvcmUuYXV0aC5jcmVkLnVpZCxcbiAgICAgICAgZGF0ZTogT2JqZWN0LmtleXMoc3RvcmUuZGF0YSlbMF0sXG4gICAgICAgIGludGlhbFRhc2s6IE9iamVjdC5rZXlzKHN0b3JlLnRhc2tzKVswXVxuICAgIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNvbm5lY3QobWFwU3RhdGVUb1Byb3BzKShTdGF0cyk7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\n//# sourceURL=webpack-internal:///482\n')}}]);